<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.5.0_06) on Mon Jun 26 19:39:53 EDT 2006 -->
<TITLE>
RawMemoryAccess (Synchronization)
</TITLE>

<META NAME="keywords" CONTENT="javax.realtime.RawMemoryAccess class">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    parent.document.title="RawMemoryAccess (Synchronization)";
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.realtime</FONT>
<BR>
Class RawMemoryAccess</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../resources/inherit.gif" ALT="extended by "><B>javax.realtime.RawMemoryAccess</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../javax/realtime/RawMemoryFloatAccess.html" title="class in javax.realtime">RawMemoryFloatAccess</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>RawMemoryAccess</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
An instance of <code>RawMemoryAccess</code> models a range of physical
 memory as a fixed sequence of bytes. A full complement of accessor 
 methods allow the contents of the physical area to be accessed through 
 offsets from the base, interpreted as byte, short, int, or long data 
 values or as arrays of these types.
 <p> 
 Whether the offset addresses the high-order or low-order byte is normally 
  based on the
  value of the <A HREF="../../javax/realtime/RealtimeSystem.html#BYTE_ORDER"><CODE>RealtimeSystem.BYTE_ORDER</CODE></A> static byte variable in 
  class <A HREF="../../javax/realtime/RealtimeSystem.html" title="class in javax.realtime"><CODE>RealtimeSystem</CODE></A>.  If the type of memory used for this 
  <code>RawMemoryAccess</code> region implements non-standard byte ordering,
  accessor methods in this class continue to select bytes 
  starting at <code>offset</code> from the base address and continuing toward 
  greater addresses.  The memory type may control the mapping of these bytes into 
  the primitive data type.  The memory type could even select bytes that are not
  contiguous.  In each case the documentation for the <A HREF="../../javax/realtime/PhysicalMemoryTypeFilter.html" title="interface in javax.realtime"><CODE>PhysicalMemoryTypeFilter</CODE></A>
  must document any mapping other than the "normal" one specified above.
 <p> 
 The <code>RawMemoryAccess</code> class allows a real-time program to implement device
 drivers, memory-mapped I/O, flash memory, battery-backed RAM, and similar
 low-level software.
 <p> 
 A raw memory area cannot contain references to Java objects.
 Such a capability would be unsafe (since it could be used to defeat
 Java's type checking) and error-prone (since it is sensitive to the
 specific representational choices made by the Java compiler).
 <p> 
 Many of the constructors and methods
 in this class throw <A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime"><CODE>OffsetOutOfBoundsException</CODE></A>. This
 exception means that the value given in the offset parameter is either
 negative or outside the memory area.
 <p> 
 Many of the constructors and methods
 in this class throw <A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime"><CODE>SizeOutOfBoundsException</CODE></A>. This
 exception means that the value given in the size parameter is either
 negative, larger than an allowable range, or would cause an accessor
 method to access an address outside of the memory area.
 <p>
  Unlike other integral parameters in this chapter, negative values are
  valid for 
  <code>byte, short, int,</code> and <code>long</code> values that are
  copied in and out of memory by the <code>set</code> and <code>get</code>
  methods of this class.
  <p>
  All offset values used in this class are measured in bytes.
  <p>
  Atomic loads and stores on raw memory are defined in terms of 
  physical memory.  This memory may be accessible to threads outside the
  JVM and to non-programmed access (e.g., DMA), consequently atomic
  access must be supported by hardware.  This specification
  is written with the assumption that all suitable hardware platforms
  support atomic loads for aligned bytes, shorts, and ints.  
  Atomic access beyond the specified minimum may be supported by the implementation.
  <p>
  Storing values into raw memory is more hardware-dependent than loading values.
  Many processor architectures do not support atomic stores of variables except for
  aligned stores of the processor's word size.  For instance, storing a byte into memory
  might require reading a 32-bit quantity into a processor register, updating the register to 
  reflect the new byte value, then re-storing the whole 32-bit quantity.  Changes to other bytes
  in the 32-bit quantity that take place between the load and the store will be lost.
 <p>
  Some processors have mechanisms that can be used to implement an atomic store of a byte, but
  those mechanisms are often slow and not universally supported.
 <p>
  This class supports unaligned access to data, but it does
  not require the implementation to make such access atomic.  Accesses to
  data aligned on its natural boundary will be atomic if the processor
  implements atomic loads and stores of that data size.
  <p>
  Except where noted, accesses to raw memory are not atomic with respect to the memory
  or with respect to schedulable objects.  A raw memory area could be 
    updated by another schedulable object, or
  even unmapped in the middle of a method.
  <p>
  The characteristics of raw-memory access are necessarily platform dependent.
  This specification provides a minimum requirement for the RTSJ platform, but it also
  supports optional system properties that identify a platform's level of support for atomic 
  raw put and get.  The properties represent a four-dimensional sparse array with boolean values
  indicating
  whether that combination of access attributes is atomic.  The default value for array entries is
  false.
  The dimension are
 <table width="95%" border="1">
 <tr> 
   <td><div align="center"><strong>Attribute</strong></div></td>
   <td><div align="center"><strong>Values</strong></div></td>
   <td><div align="center"><strong>Comment</strong></div></td>
 </tr>
 <tr> 
   <td>Access type</td>
   <td>read, write</td>
   <td>&nbsp;</td>
 </tr>
 <tr> 
   <td>Data type</td>
   <td><ul>
      <li>byte, 
      <li>short, 
      <li>int, 
      <li>long, 
      <li>float, 
      <li>double</ul></td>
   <td>&nbsp;</td>
 </tr>
 <tr> 
   <td>Alignment</td>
   <td>0 to 7</td>
   <td><p>For each data type, the possible alignments range from </p>
     <ul>
       <li>0 == aligned </li>
       <li>to data size - 1 == only the first byte of the data is <em>alignment</em> 
         bytes away from natural alignment.</li>
     </ul></td>
 </tr>
 <tr> 
   <td>Atomicity</td>
   <td><ul><li>processor, <li>smp, <li>memory</ul></td>
   <td><ul>
       <li><em>processor</em> means access is atomic with respect to other schedulable objects 
         on that processor.</li>
       <li><em>smp</em> means that access is <em>processor</em> atomic, and atomic 
         with respect across the processors in an SMP.</li>
       <li><em>memory</em> means that access is <em>smp</em> atomic, and atomic 
         with respect to all access to the memory including DMA.</li>
     </ul></td>
 </tr>
 </table>

  The true values in the table are represented by properties of the following form.
  javax.realtime.atomicaccess_&lt;access>_&lt;type>_&lt;alignment>_atomicity=true
  for example:
 <pre>
  javax.realtime.atomicaccess_read_byte_0_memory=true
 </pre>
  Table entries with a value of false may be explicitly represented, but since false
  is the default value, such properties are redundant.
 <p>
    All raw memory access is treated as volatile, and <em>serialized</em>.  The run-time must be forced to re-read
 memory or write to memory on each call to a raw memory getxxx or putxxx method, and to complete the reads and writes in the order they
 appear in the program order.
<P>

<P>
<HR>

<P>

<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryAccess.html#RawMemoryAccess(java.lang.Object, long)">RawMemoryAccess</A></B>(java.lang.Object&nbsp;type,
                long&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Construct an instance of <code>RawMemoryAccess</code> with the given parameters,
  and set the object to the mapped state.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryAccess.html#RawMemoryAccess(java.lang.Object, long, long)">RawMemoryAccess</A></B>(java.lang.Object&nbsp;type,
                long&nbsp;base,
                long&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Construct an instance of <code>RawMemoryAccess</code> with the given parameters,
  and set the object to the mapped state.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;byte</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryAccess.html#getByte(long)">getByte</A></B>(long&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the <code>byte</code> at the given offset in the memory area
  associated with this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryAccess.html#getBytes(long, byte[], int, int)">getBytes</A></B>(long&nbsp;offset,
         byte[]&nbsp;bytes,
         int&nbsp;low,
         int&nbsp;number)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets <code>number</code> bytes starting at the given offset in the memory area
  associated with this object and assigns 
 them to the byte array passed starting at position <code>low</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryAccess.html#getInt(long)">getInt</A></B>(long&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the <code>int</code> at the given offset in the memory area
  associated with this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryAccess.html#getInts(long, int[], int, int)">getInts</A></B>(long&nbsp;offset,
        int[]&nbsp;ints,
        int&nbsp;low,
        int&nbsp;number)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets <code>number</code> integers starting at the given offset in the memory area
  associated with this object and assign 
 them to the int array passed starting at position <code>low</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryAccess.html#getLong(long)">getLong</A></B>(long&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the <code>long</code> at the given offset in the memory area
  associated with this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryAccess.html#getLongs(long, long[], int, int)">getLongs</A></B>(long&nbsp;offset,
         long[]&nbsp;longs,
         int&nbsp;low,
         int&nbsp;number)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets <code>number</code> longs starting at the given offset in the memory area
  associated with this object and assign 
 them to the long array passed starting at position <code>low</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryAccess.html#getMappedAddress()">getMappedAddress</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the virtual memory location at which the memory region is mapped.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;short</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryAccess.html#getShort(long)">getShort</A></B>(long&nbsp;offset)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the <code>short</code> at the given offset in the memory area
  associated with this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryAccess.html#getShorts(long, short[], int, int)">getShorts</A></B>(long&nbsp;offset,
          short[]&nbsp;shorts,
          int&nbsp;low,
          int&nbsp;number)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets <code>number</code> shorts starting at the given offset in the memory area
  associated with this object and assign 
 them to the short array passed starting at position <code>low</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryAccess.html#map()">map</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maps the physical memory range into virtual memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryAccess.html#map(long)">map</A></B>(long&nbsp;base)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maps the physical memory range into virtual memory at the specified 
 location.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;long</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)">map</A></B>(long&nbsp;base,
    long&nbsp;size)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maps the physical memory range into virtual memory.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryAccess.html#setByte(long, byte)">setByte</A></B>(long&nbsp;offset,
        byte&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <code>byte</code> at the given offset in the memory area
  associated with this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryAccess.html#setBytes(long, byte[], int, int)">setBytes</A></B>(long&nbsp;offset,
         byte[]&nbsp;bytes,
         int&nbsp;low,
         int&nbsp;number)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets <code>number</code> bytes starting at the given offset in the memory area
  associated with this object from the 
 byte array passed starting at position <code>low</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryAccess.html#setInt(long, int)">setInt</A></B>(long&nbsp;offset,
       int&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <code>int</code> at the given offset in the memory area
  associated with this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryAccess.html#setInts(long, int[], int, int)">setInts</A></B>(long&nbsp;offset,
        int[]&nbsp;ints,
        int&nbsp;low,
        int&nbsp;number)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets <code>number</code> ints starting at the given offset in the memory area
  associated with this object from the 
 int array passed starting at position <code>low</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryAccess.html#setLong(long, long)">setLong</A></B>(long&nbsp;offset,
        long&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <code>long</code> at the given offset in the memory area
  associated with this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryAccess.html#setLongs(long, long[], int, int)">setLongs</A></B>(long&nbsp;offset,
         long[]&nbsp;longs,
         int&nbsp;low,
         int&nbsp;number)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets <code>number</code> longs starting at the given offset in the memory area
  associated with this object from the 
 long array passed starting at position <code>low</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryAccess.html#setShort(long, short)">setShort</A></B>(long&nbsp;offset,
         short&nbsp;value)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the <code>short</code> at the given offset in the memory area
  associated with this object.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryAccess.html#setShorts(long, short[], int, int)">setShorts</A></B>(long&nbsp;offset,
          short[]&nbsp;shorts,
          int&nbsp;low,
          int&nbsp;number)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets <code>number</code> shorts starting at the given offset in the memory area
  associated with this object from the 
 short array passed starting at position <code>low</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../javax/realtime/RawMemoryAccess.html#unmap()">unmap</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Unmap the physical memory range from virtual memory.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="RawMemoryAccess(java.lang.Object, long)"><!-- --></A><H3>
RawMemoryAccess</H3>
<PRE>
public <B>RawMemoryAccess</B>(java.lang.Object&nbsp;type,
                       long&nbsp;size)</PRE>
<DL>
<DD>Construct an instance of <code>RawMemoryAccess</code> with the given parameters,
  and set the object to the mapped state.
  If the platform supports virtual memory, map
  the raw memory into virtual memory.
 <p>
  The run time environment is allowed to choose the virtual address where
  the raw memory area corresponding to this object will be mapped.  The 
  attributes of the mapping operation are controlled by the vMFlags and 
  vMAttributes of the <code>PhysicalMemoryTypeFilter</code> objects 
  that matched this object's <code>type</code> parameter.  (See 
  <A HREF="../../javax/realtime/PhysicalMemoryTypeFilter.html#getVMAttributes()"><CODE>PhysicalMemoryTypeFilter.getVMAttributes()</CODE></A> 
  and <A HREF="../../javax/realtime/PhysicalMemoryTypeFilter.html#getVMFlags()"><CODE>PhysicalMemoryTypeFilter.getVMFlags()</CODE></A>.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - An instance of <code>Object</code> representing the type of
        memory required (e.g., <em>dma, shared</em>) - used to define the base address
              and control the mapping.  If the required memory has more than one
      attribute, <code>type</code> may be an array of objects.    If <code>type</code>
      is null or a reference to an array with no entries, any type of memory
      is acceptable. Note that <code>type</code> values are compared by 
      reference (==), not by value (<code>equals</code>).<DD><CODE>size</CODE> - The size of the area in bytes.
<DT><B>Throws:</B>
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if the application doesn't have
            permissions to access physical memory, the
              specified range of addresses, or the given type of memory.
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the size is negative or
            extends into an invalid range of memory.
<DD><CODE><A HREF="../../javax/realtime/UnsupportedPhysicalMemoryException.html" title="class in javax.realtime">UnsupportedPhysicalMemoryException</A></CODE> - Thrown if the underlying 
            hardware does not support the given type, or if no matching
          <A HREF="../../javax/realtime/PhysicalMemoryTypeFilter.html" title="interface in javax.realtime"><CODE>PhysicalMemoryTypeFilter</CODE></A> has been registered with
          the <A HREF="../../javax/realtime/PhysicalMemoryManager.html" title="class in javax.realtime"><CODE>PhysicalMemoryManager</CODE></A>.
<DD><CODE><A HREF="../../javax/realtime/MemoryTypeConflictException.html" title="class in javax.realtime">MemoryTypeConflictException</A></CODE> - Thrown if the specified base does not point to
            memory that matches the request type, or if <code>type</code> specifies
            incompatible memory attributes.
<DD><CODE>java.lang.OutOfMemoryError</CODE> - Thrown if the requested type of memory exists, but there is not
      enough of it free to satisfy the request.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if the application doesn't have
            permissions to access physical memory or the given range of memory.</DL>
</DL>
<HR>

<A NAME="RawMemoryAccess(java.lang.Object, long, long)"><!-- --></A><H3>
RawMemoryAccess</H3>
<PRE>
public <B>RawMemoryAccess</B>(java.lang.Object&nbsp;type,
                       long&nbsp;base,
                       long&nbsp;size)</PRE>
<DL>
<DD>Construct an instance of <code>RawMemoryAccess</code> with the given parameters,
  and set the object to the mapped state.
  If the platform supports virtual memory, map
  the raw memory into virtual memory.
 <p>
  The run time environment is allowed to choose the virtual address where
  the raw memory area corresponding to this object will be mapped.  The 
  attributes of the mapping operation are controlled by the vMFlags and 
  vMAttributes of the <code>PhysicalMemoryTypeFilter</code> objects 
  that matched this object's <code>type</code> parameter.  (See 
  <A HREF="../../javax/realtime/PhysicalMemoryTypeFilter.html#getVMAttributes()"><CODE>PhysicalMemoryTypeFilter.getVMAttributes()</CODE></A> 
  and <A HREF="../../javax/realtime/PhysicalMemoryTypeFilter.html#getVMFlags()"><CODE>PhysicalMemoryTypeFilter.getVMFlags()</CODE></A>.
<P>
<DL>
<DT><B>Parameters:</B><DD><CODE>type</CODE> - An instance of <code>Object</code> representing the type of
        memory required (e.g., <em>dma, shared</em>) - used to define the base address
              and control the mapping.  If the required memory has more than one
      attribute, <code>type</code> may be an array of objects.    If <code>type</code>
      is null or a reference to an array with no entries, any type of memory
      is acceptable. Note that <code>type</code> values are compared by 
      reference (==), not by value (<code>equals</code>).<DD><CODE>base</CODE> - The physical memory address of the region.<DD><CODE>size</CODE> - The size of the area in bytes.
<DT><B>Throws:</B>
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if application doesn't have
            permissions to access physical memory, the
              specified range of addresses, or the given type of memory.
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the address is invalid.
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the size is negative or
            extends into an invalid range of memory.
<DD><CODE><A HREF="../../javax/realtime/UnsupportedPhysicalMemoryException.html" title="class in javax.realtime">UnsupportedPhysicalMemoryException</A></CODE> - Thrown if the underlying 
            hardware does not support the given type, or if no matching
          <A HREF="../../javax/realtime/PhysicalMemoryTypeFilter.html" title="interface in javax.realtime"><CODE>PhysicalMemoryTypeFilter</CODE></A> has been registered with
          the <A HREF="../../javax/realtime/PhysicalMemoryManager.html" title="class in javax.realtime"><CODE>PhysicalMemoryManager</CODE></A>.
<DD><CODE><A HREF="../../javax/realtime/MemoryTypeConflictException.html" title="class in javax.realtime">MemoryTypeConflictException</A></CODE> - Thrown if the specified base does not point to
            memory that matches the request type, or if <code>type</code> specifies
            incompatible memory attributes.
<DD><CODE>java.lang.OutOfMemoryError</CODE> - Thrown if the requested type of memory exists, but there is not
      enough of it free to satisfy the request.</DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="getByte(long)"><!-- --></A><H3>
getByte</H3>
<PRE>
public byte <B>getByte</B>(long&nbsp;offset)</PRE>
<DL>
<DD>Gets the <code>byte</code> at the given offset in the memory area
  associated with this object.  The byte is always loaded from memory
  in a single atomic operation.
 <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory
  from which to load the byte.
<DT><B>Returns:</B><DD>The byte from raw memory.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if the byte falls in an invalid address range.
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is negative or greater than the size of the
      raw memory area.  The role of the <A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime"><CODE>SizeOutOfBoundsException</CODE></A> somewhat overlaps
      this exception since it is thrown if the offset is within the object but outside the
      mapped area. (See <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)"><CODE>map(long base, long size)</CODE></A>).
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<HR>

<A NAME="getBytes(long, byte[], int, int)"><!-- --></A><H3>
getBytes</H3>
<PRE>
public void <B>getBytes</B>(long&nbsp;offset,
                     byte[]&nbsp;bytes,
                     int&nbsp;low,
                     int&nbsp;number)</PRE>
<DL>
<DD>Gets <code>number</code> bytes starting at the given offset in the memory area
  associated with this object and assigns 
 them to the byte array passed starting at position <code>low</code>.
  Each byte is loaded from memory in a single atomic operation.  Groups of bytes
  may be loaded together, but this is unspecified.
 <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory from which to start loading.<DD><CODE>bytes</CODE> - The array into which the loaded items are placed.<DD><CODE>low</CODE> - The offset which is the starting point in the given array for the
            loaded items to be placed.<DD><CODE>number</CODE> - The number of items to load.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is negative or greater than the size of the
      raw memory area.  The role of the <A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime"><CODE>SizeOutOfBoundsException</CODE></A> somewhat overlaps
      this exception since it is thrown if the offset is within the object but outside the
      mapped area. (See <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)"><CODE>map(long base, long size)</CODE></A>).
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if the byte falls in an invalid address range.  This is checked at every
      entry in the array to allow for the possibility that the memory area
      could be unmapped or remapped.  The <code>bytes</code> array could, therefore, be
      partially updated if the raw memory is unmapped or remapped mid-method.
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - Thrown if <code>low</code> is less than 0 or greater
                than <code>bytes.length - 1</code>, or if <code>low + number</code> is greater than or 
                equal to <code>bytes.length</code>.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<HR>

<A NAME="getInt(long)"><!-- --></A><H3>
getInt</H3>
<PRE>
public int <B>getInt</B>(long&nbsp;offset)</PRE>
<DL>
<DD>Gets the <code>int</code> at the given offset in the memory area
  associated with this object.  If the integer is aligned on a "natural"
  boundary it is always loaded from memory
  in a single atomic operation.  If it is not on a natural boundary it may not be loaded atomically, and
  the number and order of the load operations is unspecified.
 <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory area 
      from which to load the integer.
<DT><B>Returns:</B><DD>The integer from raw memory.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is negative or greater than the size of the
      raw memory area.  The role of the <A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime"><CODE>SizeOutOfBoundsException</CODE></A> somewhat overlaps
      this exception since it is thrown if the offset is within the object but outside the
      mapped area. (See <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)"><CODE>map(long base, long size)</CODE></A>).
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if the integer falls in an invalid address range.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<HR>

<A NAME="getInts(long, int[], int, int)"><!-- --></A><H3>
getInts</H3>
<PRE>
public void <B>getInts</B>(long&nbsp;offset,
                    int[]&nbsp;ints,
                    int&nbsp;low,
                    int&nbsp;number)</PRE>
<DL>
<DD>Gets <code>number</code> integers starting at the given offset in the memory area
  associated with this object and assign 
 them to the int array passed starting at position <code>low</code>.
 <p>
  If the integers are aligned on natural boundaries
  each integer is loaded from memory in a single atomic operation.  Groups of integers
  may be loaded together, but this is unspecified.
<p>
  If the integers are not aligned on natural boundaries they may not be loaded atomically and
  the number and order of load operations is unspecified.
 <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory area
      at which to start loading.<DD><CODE>ints</CODE> - The array into which the integers read from the raw memory are placed.<DD><CODE>low</CODE> - The offset which is the starting point in the given array for the
            loaded items to be placed.<DD><CODE>number</CODE> - The number of integers to loaded.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is negative or greater than the size of the
      raw memory area.  The role of the <A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime"><CODE>SizeOutOfBoundsException</CODE></A> somewhat overlaps
      this exception since it is thrown if the offset is within the object but outside the
      mapped area. (See <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)"><CODE>map(long base, long size)</CODE></A>).
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if the integers fall in an invalid address range.  This is checked at every
      entry in the array to allow for the possibility that the memory area
      could be unmapped or remapped.  The <code>ints</code> array could, therefore, be
      partially updated if the raw memory is unmapped or remapped mid-method.
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - Thrown if <code>low</code> is less than 0 or greater
                than <code>bytes.length - 1</code>, or if <code>low + number</code> is greater than or 
                equal to <code>bytes.length</code>.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<HR>

<A NAME="getLong(long)"><!-- --></A><H3>
getLong</H3>
<PRE>
public long <B>getLong</B>(long&nbsp;offset)</PRE>
<DL>
<DD>Gets the <code>long</code> at the given offset in the memory area
  associated with this object.
 <p>
  The load is not required to be atomic even it is located on a natural boundary.
 <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory area
      from which to load the long.
<DT><B>Returns:</B><DD>The long from raw memory.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is invalid.
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if the double falls in an invalid address range.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<HR>

<A NAME="getLongs(long, long[], int, int)"><!-- --></A><H3>
getLongs</H3>
<PRE>
public void <B>getLongs</B>(long&nbsp;offset,
                     long[]&nbsp;longs,
                     int&nbsp;low,
                     int&nbsp;number)</PRE>
<DL>
<DD>Gets <code>number</code> longs starting at the given offset in the memory area
  associated with this object and assign 
 them to the long array passed starting at position <code>low</code>.
 <p>
  The loads are not required to be atomic even if they are located on natural boundaries.
 <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory area
      at which to start loading.<DD><CODE>longs</CODE> - The array into which the loaded items are placed.<DD><CODE>low</CODE> - The offset which is the starting point in the given array for the
            loaded items to be placed.<DD><CODE>number</CODE> - The number of longs to load.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is negative or greater than the size of the
      raw memory area.  The role of the <A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime"><CODE>SizeOutOfBoundsException</CODE></A> somewhat overlaps
      this exception since it is thrown if the offset is within the object but outside the
      mapped area. (See <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)"><CODE>map(long base, long size)</CODE></A>).
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if a long falls in an invalid address range.  This is checked at every
      entry in the array to allow for the possibility that the memory area
      could be unmapped or remapped.  The <code>longs</code> array could, therefore, be
      partially updated if the raw memory is unmapped or remapped mid-method.
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - Thrown if <code>low</code> is less than 0 or greater
                than <code>bytes.length - 1</code>, or if <code>low + number</code> is greater than or 
                equal to <code>bytes.length</code>.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<HR>

<A NAME="getMappedAddress()"><!-- --></A><H3>
getMappedAddress</H3>
<PRE>
public long <B>getMappedAddress</B>()</PRE>
<DL>
<DD>Gets the virtual memory location at which the memory region is mapped.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The virtual address to which this is mapped (for reference 
         purposes). Same as the base address if virtual memory is not supported.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalStateException</CODE> - Thrown if the raw memory object is not in the
      mapped state.</DL>
</DD>
</DL>
<HR>

<A NAME="getShort(long)"><!-- --></A><H3>
getShort</H3>
<PRE>
public short <B>getShort</B>(long&nbsp;offset)</PRE>
<DL>
<DD>Gets the <code>short</code> at the given offset in the memory area
  associated with this object. If the short is aligned on a natural
  boundary it is always loaded from memory
  in a single atomic operation.  If it is not on a natural boundary it may not be loaded atomically, and
  the number and order of the load operations is unspecified.
 <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory area
      from which to load the short.
<DT><B>Returns:</B><DD>The short loaded from raw memory.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is negative or greater than the size of the
      raw memory area.  The role of the <A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime"><CODE>SizeOutOfBoundsException</CODE></A> somewhat overlaps
      this exception since it is thrown if the offset is within the object but outside the
      mapped area. (See <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)"><CODE>map(long base, long size)</CODE></A>).
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if the short falls in an invalid address range.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<HR>

<A NAME="getShorts(long, short[], int, int)"><!-- --></A><H3>
getShorts</H3>
<PRE>
public void <B>getShorts</B>(long&nbsp;offset,
                      short[]&nbsp;shorts,
                      int&nbsp;low,
                      int&nbsp;number)</PRE>
<DL>
<DD>Gets <code>number</code> shorts starting at the given offset in the memory area
  associated with this object and assign 
 them to the short array passed starting at position <code>low</code>.
 <p>
  If the shorts are located on natural boundaries
  each short is loaded from memory in a single atomic operation.  Groups of shorts
  may be loaded together, but this is unspecified.
  <p>
  If the shorts are not located on natural boundaries the load may not be atomic, and
  the number and order of load
  operations is unspecified.
 <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory area
       from which to start loading.<DD><CODE>shorts</CODE> - The array into which the loaded items are placed.<DD><CODE>low</CODE> - The offset which is the starting point in the given array for the
            loaded shorts to be placed.<DD><CODE>number</CODE> - The number of shorts to load.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is negative or greater than the size of the
      raw memory area.  The role of the <A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime"><CODE>SizeOutOfBoundsException</CODE></A> somewhat overlaps
      this exception since it is thrown if the offset is within the object but outside the
      mapped area. (See <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)"><CODE>map(long base, long size)</CODE></A>).
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if a short falls in an invalid address range.  This is checked at every
      entry in the array to allow for the possibility that the memory area
      could be unmapped or remapped.  The <code>shorts</code> array could, therefore, be
      partially updated if the raw memory is unmapped or remapped mid-method.
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - Thrown if <code>low</code> is less than 0 or greater
                than <code>bytes.length - 1</code>, or if <code>low + number</code> is greater than or 
                equal to <code>bytes.length</code>.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<HR>

<A NAME="map()"><!-- --></A><H3>
map</H3>
<PRE>
public long <B>map</B>()</PRE>
<DL>
<DD>Maps the physical memory range into virtual memory. No-op if the system
 doesn't support virtual memory.
 <p>
  The run time environment is allowed to choose the virtual address where
  the raw memory area corresponding to this object will be mapped.  The 
  attributes of the mapping operation are controlled by the vMFlags and 
  vMAttributes of the <code>PhysicalMemoryTypeFilter</code> objects 
  that matched this object's <code>type</code> parameter.  (See 
  <A HREF="../../javax/realtime/PhysicalMemoryTypeFilter.html#getVMAttributes()"><CODE>PhysicalMemoryTypeFilter.getVMAttributes()</CODE></A> 
  and <A HREF="../../javax/realtime/PhysicalMemoryTypeFilter.html#getVMFlags()"><CODE>PhysicalMemoryTypeFilter.getVMFlags()</CODE></A>.
 <p>
  If the object is already mapped into virtual memory, this method
  does not change anything.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>The starting point of the virtual memory range.
<DT><B>Throws:</B>
<DD><CODE>java.lang.OutOfMemoryError</CODE> - Thrown if there is insufficient free virtual address
      space to map the object.</DL>
</DD>
</DL>
<HR>

<A NAME="map(long)"><!-- --></A><H3>
map</H3>
<PRE>
public long <B>map</B>(long&nbsp;base)</PRE>
<DL>
<DD>Maps the physical memory range into virtual memory at the specified 
 location. No-op if the system doesn't support virtual memory.
 <p>
  The 
  attributes of the mapping operation are controlled by the vMFlags and 
  vMAttributes of the <code>PhysicalMemoryTypeFilter</code> objects 
  that matched this object's <code>type</code> parameter.  (See 
  <A HREF="../../javax/realtime/PhysicalMemoryTypeFilter.html#getVMAttributes()"><CODE>PhysicalMemoryTypeFilter.getVMAttributes()</CODE></A> 
  and <A HREF="../../javax/realtime/PhysicalMemoryTypeFilter.html#getVMFlags()"><CODE>PhysicalMemoryTypeFilter.getVMFlags()</CODE></A>.
 <p>
  If the object is already mapped into virtual memory at a different 
  address, this method remaps it to <code>base</code>.
 <p>
  If a remap is requested while another schedulable object 
  is accessing the raw memory, the
  map will block until one load or store completes.  It can interrupt
  an array operation between entries.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>base</CODE> - The location to map at the virtual memory space.
<DT><B>Returns:</B><DD>The starting point of the virtual memory.
<DT><B>Throws:</B>
<DD><CODE>java.lang.OutOfMemoryError</CODE> - Thrown if there is insufficient free virtual
      memory at the specified address.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - Thrown if <code>base</code> is not a
      legal value for a virtual address, or the memory-mapping hardware cannot
      place the physical memory at the designated address.</DL>
</DD>
</DL>
<HR>

<A NAME="map(long, long)"><!-- --></A><H3>
map</H3>
<PRE>
public long <B>map</B>(long&nbsp;base,
                long&nbsp;size)</PRE>
<DL>
<DD>Maps the physical memory range into virtual memory. No-op if the system
 doesn't support virtual memory.
 <p>
  The attributes of the mapping operation are controlled by the vMFlags and 
  vMAttributes of the <code>PhysicalMemoryTypeFilter</code> objects 
  that matched this object's <code>type</code> parameter.  (See 
  <A HREF="../../javax/realtime/PhysicalMemoryTypeFilter.html#getVMAttributes()"><CODE>PhysicalMemoryTypeFilter.getVMAttributes()</CODE></A> 
  and <A HREF="../../javax/realtime/PhysicalMemoryTypeFilter.html#getVMFlags()"><CODE>PhysicalMemoryTypeFilter.getVMFlags()</CODE></A>.
 <p>
  If the object is already mapped into virtual memory at a different 
  address, this method remaps it to <code>base</code>.
 <p>
  If a remap is requested while another schedulable object is accessing the raw memory, the
  map will block until one load or store completes.  It can interrupt
  an array operation between entries.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>base</CODE> - The location to map at the virtual memory space.<DD><CODE>size</CODE> - The size of the block to map in.  If the size of the 
     raw memory area is greater than <code>size</code>, the object is unchanged
      but accesses beyond the mapped region will throw <A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime"><CODE>SizeOutOfBoundsException</CODE></A>.
      If the size of the raw memory area is smaller than the mapped region access to the
      raw memory will behave as if the mapped region matched the raw memory area, but
      additional virtual address space will be consumed after the end of the 
      raw memory area.
<DT><B>Returns:</B><DD>The starting point of the virtual memory.
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - Thrown if size is not greater than zero,
      <code>base</code> is not a
      legal value for a virtual address, or the memory-mapping hardware cannot
      place the physical memory at the designated address.</DL>
</DD>
</DL>
<HR>

<A NAME="setByte(long, byte)"><!-- --></A><H3>
setByte</H3>
<PRE>
public void <B>setByte</B>(long&nbsp;offset,
                    byte&nbsp;value)</PRE>
<DL>
<DD>Sets the <code>byte</code> at the given offset in the memory area
  associated with this object.
  <p>
  This memory access may involve a load and a store, and it may have unspecified
  effects on surrounding bytes in the presence of concurrent access.
 <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory area
       to which to write the byte.<DD><CODE>value</CODE> - The byte to write.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is negative or greater than the size of the
      raw memory area.  The role of the <A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime"><CODE>SizeOutOfBoundsException</CODE></A> somewhat overlaps
      this exception since it is thrown if the offset is within the object but outside the
      mapped area. (See <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)"><CODE>map(long base, long size)</CODE></A>).
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if the byte falls in an invalid address range.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<HR>

<A NAME="setBytes(long, byte[], int, int)"><!-- --></A><H3>
setBytes</H3>
<PRE>
public void <B>setBytes</B>(long&nbsp;offset,
                     byte[]&nbsp;bytes,
                     int&nbsp;low,
                     int&nbsp;number)</PRE>
<DL>
<DD>Sets <code>number</code> bytes starting at the given offset in the memory area
  associated with this object from the 
 byte array passed starting at position <code>low</code>.
  <p>
  This memory access may involve multiple load and a store operations, and it may have unspecified
  effects on surrounding bytes (even bytes in the range being stored)
  in the presence of concurrent access.
 <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory area
       to which to start writing.<DD><CODE>bytes</CODE> - The array from which the items are obtained.<DD><CODE>low</CODE> - The offset which is the starting point in the given array for the
            items to be obtained.<DD><CODE>number</CODE> - The number of items to write.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is negative or greater than the size of the
      raw memory area.  The role of the <A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime"><CODE>SizeOutOfBoundsException</CODE></A> somewhat overlaps
      this exception since it is thrown if the offset is within the object but outside the
      mapped area. (See <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)"><CODE>map(long base, long size)</CODE></A>).
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if the a short falls in an invalid address range.  This is checked at every
      entry in the array to allow for the possibility that the memory area
      could be unmapped or remapped.  The store of the array into memory could, therefore, be
      only partially  complete if the raw memory is unmapped or remapped mid-method.
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - Thrown if <code>low</code> is less than 0 or greater
                than <code>bytes.length - 1</code>, or if <code>low + number</code> is greater than or 
                equal to <code>bytes.length</code>.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<HR>

<A NAME="setInt(long, int)"><!-- --></A><H3>
setInt</H3>
<PRE>
public void <B>setInt</B>(long&nbsp;offset,
                   int&nbsp;value)</PRE>
<DL>
<DD>Sets the <code>int</code> at the given offset in the memory area
  associated with this object.
  On most processor architectures an aligned integer can be stored in an atomic operation, but
  this is not required.
  <p>
  This memory access may involve multiple load and a store operations, and it may have unspecified
  effects on surrounding bytes (even bytes in the range being stored)
  in the presence of concurrent access.
 <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory area
       at which to write the integer.<DD><CODE>value</CODE> - The integer to write.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is negative or greater than the size of the
      raw memory area.  The role of the <A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime"><CODE>SizeOutOfBoundsException</CODE></A> somewhat overlaps
      this exception since it is thrown if the offset is within the object but outside the
      mapped area. (See <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)"><CODE>map(long base, long size)</CODE></A>).
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if the integer falls in an invalid address range.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<HR>

<A NAME="setInts(long, int[], int, int)"><!-- --></A><H3>
setInts</H3>
<PRE>
public void <B>setInts</B>(long&nbsp;offset,
                    int[]&nbsp;ints,
                    int&nbsp;low,
                    int&nbsp;number)</PRE>
<DL>
<DD>Sets <code>number</code> ints starting at the given offset in the memory area
  associated with this object from the 
 int array passed starting at position <code>low</code>.
  On most processor architectures each aligned integer can be stored in an atomic operation, but
  this is not required.
  <p>
  This memory access may involve multiple load and a store operations, and it may have unspecified
  effects on surrounding bytes (even bytes in the range being stored)
  in the presence of concurrent access.
 <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory area
       at which to start writing.<DD><CODE>ints</CODE> - The array from which the items are obtained.<DD><CODE>low</CODE> - The offset which is the starting point in the given array for the
            items to be obtained.<DD><CODE>number</CODE> - The number of items to write.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is negative or greater than the size of the
      raw memory area.  The role of the <A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime"><CODE>SizeOutOfBoundsException</CODE></A> somewhat overlaps
      this exception since it is thrown if the offset is within the object but outside the
      mapped area. (See <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)"><CODE>map(long base, long size)</CODE></A>).
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if  an int falls in an invalid address range.  This is checked at every
      entry in the array to allow for the possibility that the memory area
      could be unmapped or remapped.  The store of the array into memory could, therefore, be
      only partially  complete if the raw memory is unmapped or remapped mid-method.
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - Thrown if <code>low</code> is less than 0 or greater
                than <code>bytes.length - 1</code>, or if <code>low + number</code> is greater than or 
                equal to <code>bytes.length</code>.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<HR>

<A NAME="setLong(long, long)"><!-- --></A><H3>
setLong</H3>
<PRE>
public void <B>setLong</B>(long&nbsp;offset,
                    long&nbsp;value)</PRE>
<DL>
<DD>Sets the <code>long</code> at the given offset in the memory area
  associated with this object.
  Even if it is aligned, the long value may not be updated atomically.  It is unspecified how many 
  load and store operations will be used or in what order.
  <p>
  This memory access may involve multiple load and a store operations, and it may have unspecified
  effects on surrounding bytes (even bytes in the range being stored)
  in the presence of concurrent access.
 <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory area
       at which to write the long.<DD><CODE>value</CODE> - The long to write.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is negative or greater than the size of the
      raw memory area.  The role of the <A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime"><CODE>SizeOutOfBoundsException</CODE></A> somewhat overlaps
      this exception since it is thrown if the offset is within the object but outside the
      mapped area. (See <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)"><CODE>map(long base, long size)</CODE></A>).
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if the long falls in an invalid address range.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<HR>

<A NAME="setLongs(long, long[], int, int)"><!-- --></A><H3>
setLongs</H3>
<PRE>
public void <B>setLongs</B>(long&nbsp;offset,
                     long[]&nbsp;longs,
                     int&nbsp;low,
                     int&nbsp;number)</PRE>
<DL>
<DD>Sets <code>number</code> longs starting at the given offset in the memory area
  associated with this object from the 
 long array passed starting at position <code>low</code>.
  Even if they are aligned, the long values may not be updated atomically.  It is unspecified how many 
  load and store operations will be used or in what order.
  <p>
  This memory access may involve multiple load and a store operations, and it may have unspecified
  effects on surrounding bytes (even bytes in the range being stored)
  in the presence of concurrent access.
 <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory area
       at which to start writing.<DD><CODE>longs</CODE> - The array from which the items are obtained.<DD><CODE>low</CODE> - The offset which is the starting point in the given array for the
            items to be obtained.<DD><CODE>number</CODE> - The number of items to write.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is negative or greater than the size of the
      raw memory area.  The role of the <A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime"><CODE>SizeOutOfBoundsException</CODE></A> somewhat overlaps
      this exception since it is thrown if the offset is within the object but outside the
      mapped area. (See <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)"><CODE>map(long base, long size)</CODE></A>).
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if the a short falls in an invalid address range.  This is checked at every
      entry in the array to allow for the possibility that the memory area
      could be unmapped or remapped.  The store of the array into memory could, therefore, be
      only partially  complete if the raw memory is unmapped or remapped mid-method.
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - Thrown if <code>low</code> is less than 0 or greater
                than <code>bytes.length - 1</code>, or if <code>low + number</code> is greater than or 
                equal to <code>bytes.length</code>.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<HR>

<A NAME="setShort(long, short)"><!-- --></A><H3>
setShort</H3>
<PRE>
public void <B>setShort</B>(long&nbsp;offset,
                     short&nbsp;value)</PRE>
<DL>
<DD>Sets the <code>short</code> at the given offset in the memory area
  associated with this object.
 <p>
  This memory access may involve a load and a store, and it may have unspecified
  effects on surrounding shorts in the presence of concurrent access.
  <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory area
       at which to write the short.<DD><CODE>value</CODE> - The short to write.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is negative or greater than the size of the
      raw memory area.  The role of the <A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime"><CODE>SizeOutOfBoundsException</CODE></A> somewhat overlaps
      this exception since it is thrown if the offset is within the object but outside the
      mapped area. (See <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)"><CODE>map(long base, long size)</CODE></A>).
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if the short falls in an invalid address range.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<HR>

<A NAME="setShorts(long, short[], int, int)"><!-- --></A><H3>
setShorts</H3>
<PRE>
public void <B>setShorts</B>(long&nbsp;offset,
                      short[]&nbsp;shorts,
                      int&nbsp;low,
                      int&nbsp;number)</PRE>
<DL>
<DD>Sets <code>number</code> shorts starting at the given offset in the memory area
  associated with this object from the 
 short array passed starting at position <code>low</code>.
 <p>
  Each write of a short value may involve a load and a store, and it may have unspecified
  effects on surrounding shorts in the presence of concurrent access - even on other shorts
  in the array.
 <p>
  Caching of the memory access is controlled by the memory <code>type</code> requested
  when the <code>RawMemoryAccess</code> instance was created.  If the memory is not cached,
  this method guarantees serialized access (that is, the memory access at the memory 
  occurs in the same order as in the program.  Multiple writes to the same location
  may not be coalesced.)
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>offset</CODE> - The offset in bytes from the beginning of the raw memory area
       at which to start writing.<DD><CODE>shorts</CODE> - The array from which the items are obtained.<DD><CODE>low</CODE> - The offset which is the starting point in the given array for the
            items to be obtained.<DD><CODE>number</CODE> - The number of items to write.
<DT><B>Throws:</B>
<DD><CODE><A HREF="../../javax/realtime/OffsetOutOfBoundsException.html" title="class in javax.realtime">OffsetOutOfBoundsException</A></CODE> - Thrown if the offset is negative or greater than the size of the
      raw memory area.  The role of the <A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime"><CODE>SizeOutOfBoundsException</CODE></A> somewhat overlaps
      this exception since it is thrown if the offset is within the object but outside the
      mapped area. (See <A HREF="../../javax/realtime/RawMemoryAccess.html#map(long, long)"><CODE>map(long base, long size)</CODE></A>).
<DD><CODE><A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime">SizeOutOfBoundsException</A></CODE> - Thrown if the object is not mapped,
      or if the a short falls in an invalid address range.  This is checked at every
      entry in the array to allow for the possibility that the memory area
      could be unmapped or remapped.  The store of the array into memory could, therefore, be
      only partially  complete if the raw memory is unmapped or remapped mid-method.
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - Thrown if <code>low</code> is less than 0 or greater
                than <code>bytes.length - 1</code>, or if <code>low + number</code> is greater than or 
                equal to <code>bytes.length</code>.
<DD><CODE>java.lang.SecurityException</CODE> - Thrown if this access is not permitted by the security manager.</DL>
</DD>
</DL>
<HR>

<A NAME="unmap()"><!-- --></A><H3>
unmap</H3>
<PRE>
public void <B>unmap</B>()</PRE>
<DL>
<DD>Unmap the physical memory range from virtual memory. This changes the raw memory from
  the mapped state to the unmapped state. If the platform supports
  virtual memory, this operation frees the virtual addresses used for the raw
  memory region.  
 <p>
  If the object is already in the unmapped state, this method has no effect.
  <p>
  While a raw memory object is unmapped all attempts to set or get values in
  the raw memory will throw <A HREF="../../javax/realtime/SizeOutOfBoundsException.html" title="class in javax.realtime"><CODE>SizeOutOfBoundsException</CODE></A>.
 <p>
  An unmapped raw memory object can be returned to mapped state with any of
  the object's <code>map</code> methods.
  <p>
  If an unmap is requested while another schedulable object is accessing the raw memory, the
  <code>unmap</code> will throw an <code>IllegalStateException</code>.  The
 <code>unmap</code> method can interrupt
  an array operation between entries.
<P>
<DD><DL>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<HR>

</BODY>
</HTML>
